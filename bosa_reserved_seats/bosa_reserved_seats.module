<?php
/**
 * bosa_reserved_seats module
 *
 * @author Yani Xu <yx@bellcom.dk>
 * @version $0.1
 * @copyright 2014 bellcom open source aps.
 **/

/**
 * @param $date : format - Unix timestamp
 * @param $key : the place no of the date field. like : ['und'][$key]['value']
 */
function bosa_reserved_seats_available($product_id,$date = NULL,$key = 0){
  $product = commerce_product_load($product_id);

  // The new product type "BOSA product" that contains product date and stock
  if(isset($product->field_product_date_and_stock)) {
    if ( is_numeric($date) && (int)$date == $date) {
      $date = date('d/m/Y - H:i',$date);
    }
    else {
      $date = date('d/m/Y - H:i',strtotime($date));
    }
    $info = field_get_items('commerce_product', $product, 'field_product_date_and_stock');
    $query = db_query('SELECT SUM(quantity) as quantity FROM `commerce_product`, `commerce_line_item`,
                    `field_data_field_bosa_selected_date`
                    WHERE sku = line_item_label and `product_id` = :product_id and `line_item_id` = `entity_id` and `field_bosa_selected_date_value` = :date',
                    array(':product_id' => $product_id, ':date' => $date));

    $result = $query->fetch();
    if($result){
      $count = reset($result);
    }
    if ($info[$key]['product_stock'] == 0) {
        $seats = "all";
    }
    else {
      $seats = (int)($info[$key]['product_stock'] - $count);
    }
    return $seats;
    break;
  }

  // Other product type with commerce_stock
  if($seats_field = field_get_items('commerce_product', $product, 'commerce_stock')){
    $query = db_query('SELECT SUM(quantity) as quantity FROM `commerce_product`, `commerce_line_item`
                       WHERE sku = line_item_label and `product_id` = :product_id',
                      array(':product_id' => $product_id));

    $result = $query->fetch();
    if($result){
      $count = reset($result);
    }
    $seats = $seats_field[0]['value'];
    $seats_available = $seats - $count;
    return (int)$seats_available;
  }
  // Product type that does not contain a stock field.
  else {
    return "all";
  }

}
/**
 * Implements hook_cron()
 */
function bosa_reserved_seats_cron() {
  bosa_reservation_cancel_reservations_bosa_product_type();
}
function bosa_reserved_bosa_product_order_info($product,$date,$key = NULL){
  $cancel_orders = array();
  // The new product type "BOSA product" that contains product date and stock
  if(isset($product->field_product_date_and_stock)) {
    if ( is_numeric($date) && (int)$date == $date) {
      $date = date('d/m/Y - H:i',$date);
    }
    else {
      $date = date('d/m/Y - H:i',strtotime($date));
    }
    // f.x sku = ®r¿sund
    $result = db_query('SELECT order_id, line_item_id, quantity FROM `commerce_product`, `commerce_line_item`,
                    `field_data_field_bosa_selected_date`
                    WHERE sku = line_item_label and `product_id` = :product_id and `line_item_id` = `entity_id` and `field_bosa_selected_date_value` like :date',
                    array(':product_id' => $product->product_id, ':date' => $date));
    if($result){
      foreach($result as $row) {
        // Load order and check for status.
        $order = commerce_order_load($row->order_id);
        if($order->status == 'completed'){
          $cancel_orders = array(
            'product_id' => $product->product_id,
            'order_id' => $row->order_id,
            'line_item_id' => $row->line_item_id,
            'quantity' => $row->quantity,
            'date' => $date,
          );
        }
      }
    }
  }
  return $cancel_orders;
}

/*
 * Additional cancel for the new product type "Bosa product" which contains more than one (dates + stock) fields
 * @see bosa_product_field module
 * @author Yani Xu <yx@bellcom.dk>
 */
 function bosa_reservation_cancel_reservations_bosa_product_type() {
  $orders = array();
  // fetch activity products
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'commerce_product')
      ->propertyCondition('type', 'bosa_produkt')
      ->propertyCondition('status', 1)
      ->execute();

  $product_ids = array_keys(array_shift($result));
  foreach($product_ids as $product_id) 
  {
    $product = commerce_product_load($product_id);
    $date_stock = field_get_items('commerce_product', $product, 'field_product_date_and_stock');

    if($last_min = field_get_items('commerce_product', $product, 'field_product_last_mins')) {
      $last_min = $last_min[0]['value'];
    }
    else {
      $last_min = 0;
    }

    foreach ($date_stock as $key => $item) {
      $time_tmp = strtotime($item['product_date']) + $last_min * 60 * 60;
      // If the time is later than the last date for product selling.
      // And the product is NOT cancelled.
      if (time() > $time_tmp && !$item['product_cancelled']) {
        if ($item['product_min_attendee'] == 0 || $item['product_stock'] == 0) {
          continue;
        }
        $seats_available =bosa_reserved_seats_available($product_id,strtotime($item['product_date']),$key);

        // Return "all" means stock/seat is 0 unlimited.
        // Some products does NOT contain a minimun attendent number. No need cancellation.
        if ($seats_available == "all") {
          continue;
        }

        if (($item['product_stock'] - $seats_available) < $item['product_min_attendee']) {

          // invoke rule event, sending mails
          // orders = array('product_id','order_id','date','line_item_id','quantity')
          if (bosa_reserved_bosa_product_order_info($product,$item['product_date'])) {
            $orders[$product->product_id] = bosa_reserved_bosa_product_order_info($product,$item['product_date']);
            // IF cancellation mail is NOT sent.
            if (!$item['product_cancelled_mailsent']) {
            //rules_invoke_event('bosa_reservation_bosa_product_close_to_deadline', $product, $item['product_date'], $orders);
            //$product->field_product_date_and_stock['und'][$key]['product_cancelled_mailsent'] = 1;
            //watchdog('bosa_reservation', 'Mails sent - cancel product: @product_id, on date: @date',
              // array('@product_id' => $product_id, '@date'=> $item['product_date']), WATCHDOG_NOTICE);
            }
            // IF product is NOT refunded.
            if (!$item['product_refunded']) {
            // Call refund function her.
            //$product->field_product_date_and_stock['und'][$key]['product_refunded'] = 1;
            //watchdog('bosa_reservation', 'Refunded - cancel product: @product_id, on date: @date',
            //   array('@product_id' => $product_id, '@date'=> $item['product_date']), WATCHDOG_NOTICE);
            }
          }
          // Doin some logging
          watchdog('bosa_reservation', 'cancel product: @product_id, on date: @date',
               array('@product_id' => $product_id, '@date'=> $item['product_date']), WATCHDOG_NOTICE);
 
          // Disable the product, so customers cant buy it again, 
          // and the refund action is not triggered again
          // Add set product is cancelled. So mails and refund will not be called again later.
          $product->field_product_date_and_stock['und'][$key]['product_status'] = 0;
          $product->field_product_date_and_stock['und'][$key]['product_cancelled'] = 1;
          commerce_product_save($product);
        }
      }
    }
  }
}